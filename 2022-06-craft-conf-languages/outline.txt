Opening slide
-------------

Introduce myself. Doug Creager, Semantic Code team at GitHub. Part of the "Code
Productivity" group. Code Nav, Code Search, Vulnerability Analysis, etc.

Want these features to be available for _everyone_. That means that we're
exposed to all of the programming languages that are hosted on GitHub. Which, if
you think about it, is basically the same as "all of the programming languages
in the world". So we have an interesting, very wide, perspective on languages,
which I hope to share with you today.

Tower of Babel example
----------------------

We often like to compare programming languages with spoken languages, so I want
to start with a famous myth from the Old Testament. This is a painting from the
late 1300s, depicting the Tower of Babel. If you're not familiar with this myth,
the Tower of Babel is meant to explain why people speak different languages. The
story goes that after the Great Flood of Noah, the human world was united as a
single people who spoke the same language. They were so proud of themselves and
their accomplishments that they decided to build a tower tall enough to reach
the heavens. And is often the case in the Old Testament, this is a story of God
punishing humanity for its hubris. In this case, he sundered the people,
spreading them to the corners of the Earth, and causing them to start speaking
many mutually unintelligible languages.

Now, how does this relate to the history of computing and of programming
languages? It is, admittedly, not a perfect analogy. I can't claim that there
was any _single_ programming language that the world's programmers all used in
the "prehistory" of computing. In fact, there were several groups simultaneously
trying to build human-readable programming languages on top of machine code and
assembly.

[next slide]

But we can say that there are a small handful of languages, like Fortran and
Cobol, that we consider to _share_ the crown of first.

How else is this analogy strained? Well, programmers are certainly guilty of
hubris — but I'm not going to claim that divine retribution sundered the world
of programmers in the 1950s and 1960s. Nevertheless, the end result is the same:

[next slide]

Today, there is a true multitude of programming languages.

As an aside, just throwing these logos up here has probably nerd-sniped several
of you, so

[next slide]

let's go ahead and play a game of Pyramid! There are 35 programming language
logos on the screen. Dick Clark wants to know how many of them you recognize!
Just a competition with yourself, it's okay if there many that you aren't
familiar with.

Now, for me, the most interesting part of our Tower of Babel analogy is the
"mutual unintelligibility" part. Like spoken languages, there are _families_ of
programming languages, where languages within a family are similar enough that
familiarity with one means that you're likely to understand at least the basics
of another. While in another family, the very concepts of programming are so
different that it can be almost impossible to understand how those languages
could possibly work!

[next slide]

I would claim that most of us these days are really only familiar with one
programming language and its ecosystem. We're _aware_ that other programming
languages exist, but we don't really take the time to explore other languages to
learn where the similarities and differences are. (And to be clear, that's
perfectly okay! We all have a limited number of hours in the day. Time is the
most finite resource. Learning other languages might genuinely not be the best
use of your time.)

[next slide]

So for the next 20 minutes or so, we're going to explore the multitude together.
My hope is that regardless of which language you're most fluent in, you'll see
something new that makes you think about programming differently. I firmly
believe that knowing about other programming styles and paradigms can make you a
more effective developer.

And also, to clarify, I'm going to be relentlessly positive! This is absolutely
not a sermon about the One True Programming Style that everyone should switch
over to. For those of you following along in the chat room or at home
afterwards, please stay positive too!


Recursion vs iteration
----------------------

hero image: https://flic.kr/p/5RQPx9

Factorial as a loop
  (in several imperative languages to claim that they're all "the same" and at
  this level, it's just syntax)

Factorial as a recursive function
  - Our first taste of "functional programming"
  - Focus on example in Haskell
  - also show that the recursive style is also possible in imperative languages
    like C and Rust
  - Show comparison to the "math" definition of factorial

Implementation concerns — stack space
  - Show fixed/reused space for imperative loop
  - but linear growth of call stacks for recursive function

Show that loop style is also possible in Haskell (everything that's Turing
complete is Turing complete), and it does guarantee that you use fixed space,
but it's fighting against the grain of the language

Instead, rewrite using the iterative recursion pattern
  - Drawback: code no longer "obviously" lines up with math definition
  - Can we make compilers that are smart enough to translate the former into the
    latter? So that we can write the "obviously correct" thing, and let the
    computer figure out how to make it run most efficiently on our hardware. If
    this kind of question interests you, you might have a career in PL research
    ahead of you!

Another interesting benefit of the recursive style, and of functional
programming in general, is that it makes it easier to look for higher level
patterns. Not just "oh there are lots of problems that we can solve with
recursion". But going deeper: "How many times do we recurse?" "How much work are
we allowed to do before the recursive call?" "How much work after?"

[Figure out how a couple of recursion schemes map to the answers to those
questions]

(Now do you see what I mean about "mutual unintelligibility" being the most
important part of the Tower of Babel myth?)


Error handling
--------------

hero image: https://flic.kr/p/B9WA8y

exceptions
enums / either / monad / try


Resources and cleanup
---------------------

hero image: https://flic.kr/p/eRjo3W

GC for memory
malloc + free manually in C
smart pointer / ownership in Rust (GC is not the only automatic memory
management!)

Other resources?

Closing a file after you're done with it
GC finalizers don't work
Need defer or with
RAII in C++ and Rust

Make sure it works in all of your return paths!


Concurrency
-----------

hero image: https://flic.kr/p/NpqGS

OS threads
green threads / goroutines
evented: promises, futures, async
Just do it single threaded! (Coordination always has an overhead)


Conclusion
----------

hero image: https://flic.kr/p/NHDXRb

We've come to the end of our journey. We still have a multitude of programming
languages (and always will!). But hopefully I've been able to add a bit of order
to that multitude for you today.

If you've encountered a new style of programming that used to be completely
alien to you, consider if there are any parts of it that you can bring back to
your native language and ecosystem. If there aren't, you can at least be
thankful that you now have a better, more mindful appreciation for the ways
things are done in your language. And if you do find yourself with some spare
time for personal learning and experimentation, consider implementing a toy
project in a language that's completely outside your comfort zone. It will be
worth the effort!

Thanks for your time!
